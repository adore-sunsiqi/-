# 1、野指针

野指针的定义：指针指向的位置是不可知的。

产生原因：1、指针被释放后没有被置为空；2、指针变量声明的时候没有初始化；3、越界操作。

解决办法：1、置空；2、初始化；3、使用智能指针。

# 2、悬空指针

指针指向的对象已经被删除。

# 3、C++内存分配

1、栈空间。由编译器自动分配和释放内存，存放局部变量、函数参数、函数调用和临时变量等。

2、堆空间。由程序员通过new、delete等运算符（malloc、free）进行分配和释放。存放动态分配内存的变量。

3、全局/静态存储区。程序结束自动释放内存。存放全局变量和静态变量。函数体内的静态变量只在该函数体内有效。

# 4、内存泄漏

定义：已动态分配的堆内存由于某些原因未被释放。

产生原因：1、为释放动态分配的内存；2、丢失引用；3、循环引用；4、文件或资源未关闭。

检测方法：1、Windows系统下使用CRT中的库函数；2、Linux系统下使用工具Valgrind；步骤是首先gcc -g编译程序，其次valgrind ./可执行程序名进行检测，最后查看检测报告（如definitely Lost）。

定位：调用前后生成快的快照，比较前后的状态。

# 5、内存溢出

定义：写入数据时，超出该缓冲区的大小。

1、堆溢出。

原因：1、动态分配内存错误；2、缓冲区错误，如边界检查错误，写入数量超出；3、野指针；4、悬空指针。

错误：1、内存访问错误，如覆盖相邻内存、访问非法指针、段错误；2、程序崩溃\异常终止，生成core文件；3、内存泄漏。

2、栈溢出。

原因：1、递归调用深度过大；2、局部变量过多过大；3、无限递归；4、缓冲区溢出。

错误：1、栈溢出异常，导致程序崩溃或终止，生成core文件；2、重写返回地址；3、内存破坏。

# 6、内存塌陷

定义：对内存进行了非法操作，导致内存数据结构被破坏，内存泄漏的一种特殊情况，是一种持续性的内存泄漏。

解决方法：1、定期代码审查；2、valgrind检测；3、使用安全的函数，如安全的字符串函数strcpy_s()。

# 7、C指针和数组的关系

数组是内存中的一块连续的地址空间，对数组的访问可以通过指针去实现。包括二重指针。

# 8、C++是类型安全的语言吗？

C++是一种静态语言，提供类型安全。

# 9、C++的三大特性

1、继承：代码重用。

2、封装：将数据和方法封装成类，隐藏具体的实现细节。

3、多态：接口重用。

静态多态：编译时多态，通过函数重载实现。

动态多态：运行时多态，通过函数重写实现。

# 10、重载、重写、隐藏的区别

1、重载：同一个类中，相同的函数名，通过改变形参的类型或者数量来实现。类似C语言中的宏。

2、重写：在父类和派生类之间，即不同的类之间，通过虚函数来实现。

3、隐藏：派生类和父类中的某个函数重名，但参数不同，无论有无virtual关键字，父类函数被隐藏。

派生类和父类中的某个函数重名，并且参数相同，但是没有virtual关键字，父类中的函数被隐藏。

# 11、深拷贝和浅拷贝

深拷贝：增加了一个指针，并且申请了一个新的内存。修改A的时候，B不会发生变化。真正的复制。

浅拷贝：只增加了一个指针，指向同一块内存。修改A的时候，B也会发生变化。只是引用。

# 12、虚函数

虚函数是实现函数重写和多态的方式。

静态成员函数不能是虚函数；

普通函数不能是虚函数；

构造函数不能是虚函数： 构造函数如果被声明为虚函数，那么需要通过虚函数表中的虚函数指针来调用构造函数，但是对象还没有实例化，不存在虚函数指针。

析构函数可以是虚函数： 为了避免内存泄漏。

内联函数不能是虚函数： 因为不能在运行时确定内联函数的位置。

父类可以访问派生类中的对父类中的虚函数重写的函数。派生类可以重新定义父类中的权限为private的函数，但是不能访问父类中的权限为private的函数。

# 13、C++中类的权限

public：struct结构体的默认权限，可提供类内、类外、派生类的访问。

private：class类的默认权限，提供类内、友元的访问。

protected：提供类内、友元、派生类的访问。

# 14、字符串复制函数strcpy()、内存复制函数memcpy()的区别

strcpy()：以bit为单位，复制的内容包括 \0 结束符。

memcpy()：以字节为单位，适用于任何类型的数据复制。

length()、strlen()等字符串长度计算函数，计算的字符串长度不包括 \0 结束符。

# 15、指针的长度

使用sizeof(ptr)函数来计算指针的长度，指针的长度不受数据类型的限制，在32位OS中是4Byte，在64位OS中是8字节。

# 16、用户空间和系统内核的通信方式

1、系统调用；2、内存映射。

# 17、程序的四个阶段

1、预处理：头文件包含、条件编译、宏替换、注释移除。生成 .i 文件。

2、编译：生成机器可执行的目标代码。生成 .s 文件。

3、汇编：将目标代码进行符号解析和指令翻译，转换成机器指令。生成 .o 文件。

4、链接：将目标文件和所需要的库文件链接到一起，生成 .exe或 .out文件。

# 18、const和define的区别

const和define都可以用来声明常量。

1、const：编译运行期间；有具体的类型和类型检查；分配内存。

2、define：预处理期间；没有类型；仅宏展开，不涉及内存分配。

# 19、1G的物理内存可以申请malloc(1.2G)内存吗？

malloc申请的内存空间和虚拟地址空间有关。64位操作系统的虚拟地址空间可达到2^64字节。

# 20、extern C

extern用来插入可执行的C代码。由extern关键字声明的常量可以在多个文件中访问（extern const int buf）。可多次声明，但只能定义一次。

# 21、数组指针、指针数组、函数指针、指针函数

1、数组**指针**：指向数组的指针，是一个指针变量，占用一个指针的内存。char (*array)[5]:指向存放5个字符型数据数组的指针。

2、指针**数组**：多个指针变量以数组的形式存放在内存中，本质是一个数组，元素是地址。char * array[5]：存放5个字符型指针的数组。

3、函数**指针**：本质是指针，指向一个函数。常用于**回调函数**。int (*fun)(int arg)。

4、指针**函数**：本质是函数，返回值是一个指针。int * fun(int arg)。

# 22、auto类型说明符

自动类型说明符，在不知道变量类型的时候使用。但是右值要显示表示。

# 23、STL

1、数组array：

2、向量vector：连续存储、自动扩容、随机存取。自动扩容的机制是：检查空间是否满，若满，则分配1.5～2倍内存，然后内存复制，然后旧内存释放。

3、列表list：双向链表。

4、堆heap：二叉树。自动排序。

5、栈stack：先进后出。

6、队列queue：先进先出。

7、优先队列priority-queue：

8、集合set：红黑树，元素查找快；元素不重复；自动排序。

9、哈希映射hashmap：数组+链表：解决哈希冲突，提高插入和查找效率，也可使用红黑树；键值对：使用哈希函数对键进行哈希构造hashtable；适用于频繁的根据键来访问和修改数据，复杂度为O(1)；动态扩容。

减少哈希表hashtable冲突的方法：1、选用好的哈希函数；2、负载因子（插入元素的数量与桶的数量之比）保持在0.7~0.8，扩容；3、链表；4、开放地址法。

对哈希表hashtable并行读写：互斥锁；读写锁；分离锁；并发数据结构。

# 24、动态库和静态库

编译器默认使用动态链接。

1、静态链接：目标文件+所有的库文件合并成一个可执行文件，多个可执行文件会产生包含。编译链接阶段；用自己的库；快。

2、动态链接：可执行文件和所用到的动态库文件单独存放。运行时；动态加载到内存；慢。

# 25、使用makefile制作动态库

需四步：1、指定编译器设置；2、定义规则；3、清理文件；4、使用make命令执行。

CC = gcc                          编译器指令：默认gcc

CFLAGS = -Wall -fPIC              编译选项：-Wall表示启用所有警告，-fPIC表示生成位置独立的代码

LDFLAGS = -share                  连接选项：-shared表示生成一个动态库

TARGET = libexample.so            目标动态库的名称

SRCS = example.c                  源文件列表，这里只有一个example.c

OBJS = $(SRCS:.c=.o)              目标文件列表，根据源文件列表生成

.PHONY: all clean                 指示 all 和 clean 是伪目标。无论是否存在同名的文件，执行这些目标都会执行目标中定义的操作。可以避免因为存在同名文件而导致构建过程无法正确执行的问题

all: $(TARGET)                    默认规则，执行$(TARGET)规则。如果没有指定的规则，默认执行all规则。

$(TARGET): $(OBJS)                生成目标动态库的规则，依赖于$(OBJS)规则

	$(CC) $(LDFLAGS) -o $@ $^       使用$(CC)和$(LDFLAGS)进行链接

$(OBJS): $(SRCS)                  生成目标文件的规则，依赖于对应的源文件

	$(CC) $(CFLAGS) -c $< -o $@     使用$(CC)和$(CFLAGS)进行编译

clean:                            清理生成的目标文件和动态库。通过执行命令make clean。

	rm -f $(OBJS) $(TARGET)

# 26、查看core文件

# 27、静态变量什么时候初始化？

C中全局变量和静态变量初始化（未定义的将被初始化为0）发生在任何代码之前，发生在编译期。

C++中当且仅当对象首次使用时才构造。但是全局对象在main函数之前就调用构造函数进行构造了。

# 28、nullptr可以调用成员函数吗？

编译时对象就绑定了函数地址，和指针是否为空无关。

# 29、C++四种类型转换

1、static_cast：用的最多；用于隐式转换，非const转const，void*转指针等。

2、dynamic_cast:动态类型转换；用于含有虚函数的类进行类层次间的向上向下转化；只能用于转换指针和引用；非法向下转化时，对于指针则返回NULL，对于引用则抛出异常。

3、const_cast：const转换非const。

4、reinterpret_cast：

# 30、必须在构造函数初始化式中进行初始化的数据成员

1、常量成员；2、引用类型

# 31、如何让一个类不能实例化？

将类定义为抽象基类；将构造函数声明为私有private。

# 32、C++创建一个类，使其只能在堆空间上或者栈空间上创建对象

1、只在堆内存创建：将析构函数声明为私有private。

原因：C++是静态语言，编译器管理栈空间上对象的生命周期，在对类对象分配栈空间时，会先检查类的析构函数的访问性，若不可访问，则不能在栈空间上创建对象。

2、只在栈内存创建：将new和delete运算符重载为私有private。

原因：在堆空间上生成对象需要使用new运算符。需要两步：1、new在堆内存上寻找可用内存；2、调用构造函数生成对象。new被重载为私有，则无法在堆空间上寻找可用内存，导致无法在堆内存上创建对象。

# 33、main函数之前可以执行函数吗？

可以。

1、C++中在main函数之前定义一个全局对象，然后系统会在main函数执行前调用该全局对象的构造函数。原因：在C++中，全局对象的构造函数在main()函数之前会被调用。在程序启动时，静态全局对象和全局变量的构造函数会在main()函数执行之前自动调用。这是因为当程序开始运行时，首先会进行全局/静态存储区的初始化，其中包括全局变量和静态全局对象。这些对象的构造函数会在程序启动时自动调用，而不需要显式调用。

2、C中使用gcc的attribute关键字，声明constructor和destructor。使用__attribute__((constructor))关键字可以声明一个函数在程序启动时自动执行。这个函数会在main函数之前执行，并且可以用于执行一些初始化任务。但是尽管构造函数在程序启动时自动执行，但在程序退出时，并不会自动调用析构函数。如果需要在程序退出时执行一些清理任务，可以使用__attribute__((destructor))关键字来声明析构函数。

#include <stdio.h>

void my_constructor(void) __attribute__((constructor));

void my_constructor(void) {

    printf("Constructor called!\n"); 
    
}

int main() {

    printf("Main function\n");
    
    return 0;
    
}

# 34、流量控制和拥塞控制

流量控制：点对点通信，解决端到端问题；目的是抑制发送端的发送速率，使接受端来得及接收。

拥塞控制：整体上考量；目的是防止过多的数据注入网络中，防止路由器或链路过载。

# 35、异常和中断的区别

异常：软件触发；用于处理程序运行时的错误；异常处理器。

中断：硬件触发或者操作系统控制器的信号触发；用于响应特定事件；

# 36、空结构体调用sizeof()的返回值

1字节。确保结构体实例在内存中具有不同的地址。

# 37、百万数据中查找TOP-K元素

K堆排序：建立一个K个元素的堆，不断移除栈顶元素。

# 38、



