# 1、野指针

野指针的定义：指针指向的位置是不可知的。

产生原因：1、指针被释放后没有被置为空；2、指针变量声明的时候没有初始化；3、越界操作。

解决办法：1、置空；2、初始化；3、使用智能指针。

# 2、悬空指针

指针指向的对象已经被删除。

# 3、C++内存分配

1、栈空间。由编译器自动分配和释放内存，存放局部变量、函数参数、函数调用和临时变量等。

2、堆空间。由程序员通过new、delete等运算符（malloc、free）进行分配和释放。存放动态分配内存的变量。

3、全局/静态存储区。程序结束自动释放内存。存放全局变量和静态变量。函数体内的静态变量只在该函数体内有效。

# 4、内存泄漏

定义：已动态分配的堆内存由于某些原因未被释放。

产生原因：1、为释放动态分配的内存；2、丢失引用；3、循环引用；4、文件或资源未关闭。

检测方法：1、Windows系统下使用CRT中的库函数；2、Linux系统下使用工具Valgrind；步骤是首先gcc -g编译程序，其次valgrind ./可执行程序名进行检测，最后查看检测报告（如definitely Lost）。

定位：调用前后生成快的快照，比较前后的状态。

# 5、内存溢出

定义：写入数据时，超出该缓冲区的大小。

1、堆溢出。

原因：1、动态分配内存错误；2、缓冲区错误，如边界检查错误，写入数量超出；3、野指针；4、悬空指针。

错误：1、内存访问错误，如覆盖相邻内存、访问非法指针、段错误；2、程序崩溃\异常终止，生成core文件；3、内存泄漏。

2、栈溢出。

原因：1、递归调用深度过大；2、局部变量过多过大；3、无限递归；4、缓冲区溢出。

错误：1、栈溢出异常，导致程序崩溃或终止，生成core文件；2、重写返回地址；3、内存破坏。

# 6、内存塌陷

定义：对内存进行了非法操作，导致内存数据结构被破坏，内存泄漏的一种特殊情况，是一种持续性的内存泄漏。

解决方法：1、定期代码审查；2、valgrind检测；3、使用安全的函数，如安全的字符串函数strcpy_s()。

# 7、C指针和数组的关系

数组是内存中的一块连续的地址空间，对数组的访问可以通过指针去实现。包括二重指针。

# 8、C++是类型安全的语言吗？

C++是一种静态语言，提供类型安全。

# 9、C++的三大特性

1、继承：代码重用。

2、封装：将数据和方法封装成类，隐藏具体的实现细节。

3、多态：接口重用。

静态多态：编译时多态，通过函数重载实现。

动态多态：运行时多态，通过函数重写实现。

# 10、重载、重写、隐藏的区别

1、重载：同一个类中，相同的函数名，通过改变形参的类型或者数量来实现。类似C语言中的宏。

2、重写：在父类和派生类之间，即不同的类之间，通过虚函数来实现。

3、隐藏：派生类和父类中的某个函数重名，但参数不同，无论有无virtual关键字，父类函数被隐藏。

派生类和父类中的某个函数重名，并且参数相同，但是没有virtual关键字，父类中的函数被隐藏。

# 11、深拷贝和浅拷贝

深拷贝：增加了一个指针，并且申请了一个新的内存。修改A的时候，B不会发生变化。真正的复制。

浅拷贝：只增加了一个指针，指向同一块内存。修改A的时候，B也会发生变化。只是引用。

# 12、虚函数

虚函数是实现函数重写和多态的方式。

静态成员函数不能是虚函数；

普通函数不能是虚函数；

构造函数不能是虚函数： 构造函数如果被声明为虚函数，那么需要通过虚函数表中的虚函数指针来调用构造函数，但是对象还没有实例化，不存在虚函数指针。

析构函数可以是虚函数： 为了避免内存泄漏。

内联函数不能是虚函数： 因为不能在运行时确定内联函数的位置。

父类可以访问派生类中的对父类中的虚函数重写的函数。派生类可以重新定义父类中的权限为private的函数，但是不能访问父类中的权限为private的函数。

# 13、C++中类的权限

public：struct结构体的默认权限，可提供类内、类外、派生类的访问。

private：class类的默认权限，提供类内、友元的访问。

protected：提供类内、友元、派生类的访问。

# 14、字符串复制函数strcpy()、内存复制函数memcpy()的区别

strcpy()：以bit为单位，复制的内容包括 \0 结束符。

memcpy()：以字节为单位，适用于任何类型的数据复制。

length()、strlen()等字符串长度计算函数，计算的字符串长度不包括 \0 结束符。

# 15、指针的长度



